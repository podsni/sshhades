package github

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/go-github/v57/github"
	"golang.org/x/oauth2"
)

// Client wraps GitHub API client
type Client struct {
	client *github.Client
	owner  string
	repo   string
}

// NewClient creates a new GitHub client
func NewClient(token, repository string) (*Client, error) {
	if token == "" {
		token = os.Getenv("GITHUB_TOKEN")
	}

	if token == "" {
		return nil, fmt.Errorf("GitHub token required (use --github-token flag or GITHUB_TOKEN env var)")
	}

	if repository == "" {
		return nil, fmt.Errorf("repository required in format owner/repo")
	}

	parts := strings.Split(repository, "/")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid repository format, expected owner/repo")
	}

	// Create OAuth2 token source
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: token},
	)
	tc := oauth2.NewClient(context.Background(), ts)

	// Create GitHub client
	client := github.NewClient(tc)

	return &Client{
		client: client,
		owner:  parts[0],
		repo:   parts[1],
	}, nil
}

// UploadFile uploads an encrypted SSH key file to GitHub repository
func (c *Client) UploadFile(ctx context.Context, localPath, remotePath, commitMessage string) error {
	// Read file content
	content, err := os.ReadFile(localPath)
	if err != nil {
		return fmt.Errorf("failed to read file: %w", err)
	}

	// Prepare file options
	opts := &github.RepositoryContentFileOptions{
		Message: github.String(commitMessage),
		Content: content,
		Branch:  github.String("main"), // You might want to make this configurable
	}

	// Check if file already exists
	existingFile, _, resp, err := c.client.Repositories.GetContents(ctx, c.owner, c.repo, remotePath, nil)
	if err != nil && resp.StatusCode != 404 {
		return fmt.Errorf("failed to check existing file: %w", err)
	}

	// If file exists, we need to provide the SHA for update
	if existingFile != nil {
		opts.SHA = existingFile.SHA
		opts.Message = github.String(fmt.Sprintf("Update %s", commitMessage))
	}

	// Upload or update file
	_, _, err = c.client.Repositories.CreateFile(ctx, c.owner, c.repo, remotePath, opts)
	if err != nil {
		return fmt.Errorf("failed to upload file to GitHub: %w", err)
	}

	return nil
}

// EnsureRepository checks if repository exists and creates directory structure
func (c *Client) EnsureRepository(ctx context.Context) error {
	// Check if repository exists
	_, _, err := c.client.Repositories.Get(ctx, c.owner, c.repo)
	if err != nil {
		return fmt.Errorf("repository %s/%s not accessible: %w", c.owner, c.repo, err)
	}

	// Create ssh-keys directory if it doesn't exist
	sshKeysPath := "ssh-keys"
	_, _, resp, err := c.client.Repositories.GetContents(ctx, c.owner, c.repo, sshKeysPath, nil)
	
	if err != nil && resp.StatusCode == 404 {
		// Directory doesn't exist, create it with a README
		readmeContent := `# SSH Keys Backup

This directory contains encrypted SSH key backups created by SSH Hades.

⚠️ **Security Notice**: 
- Only encrypted .enc files should be stored here
- Never commit raw SSH private keys
- Ensure this repository is private

## File Format
Each .enc file contains:
- AES-256-GCM encrypted SSH key data
- Argon2id key derivation metadata
- Authentication tags for integrity verification

Generated by [SSH Hades](https://github.com/sshhades/sshhades)
`

		opts := &github.RepositoryContentFileOptions{
			Message: github.String("Initialize ssh-keys backup directory"),
			Content: []byte(readmeContent),
			Branch:  github.String("main"),
		}

		_, _, err = c.client.Repositories.CreateFile(ctx, c.owner, c.repo, filepath.Join(sshKeysPath, "README.md"), opts)
		if err != nil {
			return fmt.Errorf("failed to create ssh-keys directory: %w", err)
		}
	}

	return nil
}

// CreateGitignore creates or updates .gitignore to prevent committing raw keys
func (c *Client) CreateGitignore(ctx context.Context) error {
	gitignoreContent := `# SSH Hades - Prevent raw key commits
# Only allow encrypted .enc files

# Raw SSH keys (never commit these!)
id_*
!id_*.enc
*.pem
*.key
!*.enc

# Temporary files
*.tmp
*.bak
*.swp
*~

# Environment files
.env
.env.local
.env.*.local

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
`

	opts := &github.RepositoryContentFileOptions{
		Message: github.String("Add .gitignore for SSH key safety"),
		Content: []byte(gitignoreContent),
		Branch:  github.String("main"),
	}

	// Check if .gitignore already exists
	existingFile, _, resp, err := c.client.Repositories.GetContents(ctx, c.owner, c.repo, ".gitignore", nil)
	if err != nil && resp.StatusCode != 404 {
		return fmt.Errorf("failed to check existing .gitignore: %w", err)
	}

	// If .gitignore exists, append our rules instead of overwriting
	if existingFile != nil {
		existingContent, err := existingFile.GetContent()
		if err != nil {
			return fmt.Errorf("failed to get existing .gitignore content: %w", err)
		}

		// Only add our rules if they're not already present
		if !strings.Contains(existingContent, "SSH Hades") {
			newContent := existingContent + "\n\n" + gitignoreContent
			opts.Content = []byte(newContent)
			opts.SHA = existingFile.SHA
			opts.Message = github.String("Update .gitignore for SSH Hades key safety")
		} else {
			// Rules already exist, no need to update
			return nil
		}
	}

	_, _, err = c.client.Repositories.CreateFile(ctx, c.owner, c.repo, ".gitignore", opts)
	if err != nil {
		return fmt.Errorf("failed to create/update .gitignore: %w", err)
	}

	return nil
}

// GenerateRemotePath creates a standard remote path for encrypted key files
func GenerateRemotePath(localPath string) string {
	filename := filepath.Base(localPath)
	return filepath.Join("ssh-keys", filename)
}

// GenerateCommitMessage creates a descriptive commit message
func GenerateCommitMessage(filename, comment string) string {
	message := fmt.Sprintf("Backup encrypted SSH key: %s", filename)
	
	if comment != "" {
		message += fmt.Sprintf(" (%s)", comment)
	}
	
	message += fmt.Sprintf(" - %s", time.Now().UTC().Format("2006-01-02 15:04:05 UTC"))
	
	return message
}